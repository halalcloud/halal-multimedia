#include "stdAfx.h"
#include "mpeg2.h"
#include "ProgramSpecialInformationParserTest.h"
CPPUNIT_TEST_SUITE_REGISTRATION(CProgramSpecialInformationParserTest);

CProgramSpecialInformationParserTest::CProgramSpecialInformationParserTest(void)
{
	m_parser = NULL;
}

CProgramSpecialInformationParserTest::~CProgramSpecialInformationParserTest(void)
{
	m_parser = NULL;
}

void CProgramSpecialInformationParserTest::setUp()
{

}

void CProgramSpecialInformationParserTest::tearDown()
{

}

void CProgramSpecialInformationParserTest::PmtParserTest()
{
	{
	//* {{ 解析单包的PMT.
	m_parser = new wzd::CProgramSpecialInformationParser;
	//* 要先解PAT.
	unsigned char buf1[] = {0x00, 0xB0,0x0D,0x00,0x01,0xC1,0x00,0x00,0x00,0x01,0xEF,0xFF,0x36,0x90,0xE2,0x3D,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
	const unsigned char * pByte1 = buf1;
	int iRet = 0;
	CPPUNIT_ASSERT_NO_THROW(iRet = m_parser->Parser(pByte1, sizeof(buf1), 0x00));
	CPPUNIT_ASSERT(iRet == 1);
	//* PMT 解析.
	unsigned char buf[] = {0x02,0xB0,0x1D,0x00,0x01,0xC1,0x00,0x00,0xE1,0x00,0xF0,0x00,0x1B,0xE1,0x00,0xF0,0x00,0x0F,0xE1,0x01,0xF0,0x06,0x0A,0x04,0x75,0x6E,0x64,0x00,0x08,0x7D,0xE8,0x77,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
	const unsigned char * pByte = buf;
	CPPUNIT_ASSERT_NO_THROW(iRet = m_parser->Parser(pByte, sizeof(buf), 0xfff));
	CPPUNIT_ASSERT(0 == iRet);
	const vector<wzd::ProgramMapSection>& pmts = m_parser->GetPMT();
	CPPUNIT_ASSERT(pmts.size() == 1);
	wzd::ProgramMapSection pmt = *(pmts.begin());
	CPPUNIT_ASSERT(2 == pmt.table_id);
	CPPUNIT_ASSERT(1 == pmt.section_syntax_indicator);
	CPPUNIT_ASSERT(0x1d == pmt.section_length);
	CPPUNIT_ASSERT(1 == pmt.program_number);
	CPPUNIT_ASSERT(0 == pmt.version_number);
	CPPUNIT_ASSERT(1 == pmt.current_next_indicator);
	CPPUNIT_ASSERT(0 == pmt.section_number);
	CPPUNIT_ASSERT(0 == pmt.last_section_number);
	CPPUNIT_ASSERT(0x0100 == pmt.PCR_PID);
	CPPUNIT_ASSERT(0 == pmt.program_info_length);
	CPPUNIT_ASSERT(pmt.esInfo.size() == 2);
	wzd::ProgramMapSection::ES_info esInfo = pmt.esInfo[0];
	CPPUNIT_ASSERT(0x1b == esInfo.stream_type);
	CPPUNIT_ASSERT(0x0100 == esInfo.elementary_PID);
	CPPUNIT_ASSERT(0 == esInfo.ES_info_length);
	esInfo = pmt.esInfo[1];
	CPPUNIT_ASSERT(0x0f == esInfo.stream_type);
	CPPUNIT_ASSERT(0x0101 == esInfo.elementary_PID);
	CPPUNIT_ASSERT(0x0006 == esInfo.ES_info_length);

	delete m_parser;
	m_parser = NULL;
	//* }} */
	}

	//{
	//* {{
	//* 有Program_info的PMT.
	//* 先解PAT.
	m_parser = new wzd::CProgramSpecialInformationParser;
	unsigned char buf[] = {0x00,0xB0,0x3D,0x00,0x08,0xC3,0x00,0x00,0x00,0x04,0xE1,0x00,0x00,0x01,0xE1,0x01,0x00,0x03,0xE1,0x02,0x00,0x05,0xE1,0x19,0x00,0x06,0xE1,0x1F,0x00,0x07,0xE1,0x22,0x00,0x08,0xE1,0x23,0x00,0x09,0xE1,0x24,0x00,0x0A,0xE1,0x2B,0x00,0x0B,0xE1,0x35,0x00,0x0C,0xE1,0x36,0x00,0x02,0xE1,0x37,0x00,0x0D,0xE1,0x38,0x52,0x97,0xD7,0xBC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
	const unsigned char* pByte = buf;
	int iRet = 0;
	CPPUNIT_ASSERT_NO_THROW(iRet = m_parser->Parser(pByte, sizeof(buf), 0x00));
	CPPUNIT_ASSERT(iRet == 1);
	//* 再解PMT.
	unsigned char buf1[] = {0x02,0xB0,0x31,0x00,0x07,0xC7,0x00,0x00,0xE1,0x1A,0xF0,0x0C,0x0B,0x02,0x4A,0x1F,0x10,0x06,0xC0,0x1D,0xC6,0xC0,0x08,0x00,0x02,0xE1,0x20,0xF0,0x05,0x02,0x03,0x1A,0x48,0x5F,0x04,0xE1,0x21,0xF0,0x09,0x03,0x01,0x67,0x0A,0x04,0x65,0x6E,0x67,0x00,0xA1,0x27,0x72,0x42,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
	pByte = buf1;
	CPPUNIT_ASSERT_NO_THROW(iRet = m_parser->Parser(pByte, sizeof(buf1), 0x122));
	CPPUNIT_ASSERT(1 == iRet);
	const vector<wzd::ProgramMapSection>& pmts = m_parser->GetPMT();
	CPPUNIT_ASSERT(pmts.size() == 1);
	wzd::ProgramMapSection pmt = *(pmts.begin());
	CPPUNIT_ASSERT(2 == pmt.table_id);
	CPPUNIT_ASSERT(1 == pmt.section_syntax_indicator);
	CPPUNIT_ASSERT(0x31 == pmt.section_length);
	CPPUNIT_ASSERT(0x0007 == pmt.program_number);
	CPPUNIT_ASSERT(0x03 == pmt.version_number);
	CPPUNIT_ASSERT(1 == pmt.current_next_indicator);
	CPPUNIT_ASSERT(0 == pmt.section_number);
	CPPUNIT_ASSERT(0 == pmt.last_section_number);
	CPPUNIT_ASSERT(0x011a == pmt.PCR_PID);
	CPPUNIT_ASSERT(0x000c == pmt.program_info_length);
	CPPUNIT_ASSERT(pmt.esInfo.size() == 2);
	wzd::ProgramMapSection::ES_info esInfo = pmt.esInfo[0];
	CPPUNIT_ASSERT(0x2 == esInfo.stream_type);
	CPPUNIT_ASSERT(0x0120 == esInfo.elementary_PID);
	CPPUNIT_ASSERT(5 == esInfo.ES_info_length);
	esInfo = pmt.esInfo[1];
	CPPUNIT_ASSERT(0x04 == esInfo.stream_type);
	CPPUNIT_ASSERT(0x0121 == esInfo.elementary_PID);
	CPPUNIT_ASSERT(0x0009 == esInfo.ES_info_length);
	//* }} */
	//}
}

void CProgramSpecialInformationParserTest::PatParserTest()
{
	{
	m_parser = new wzd::CProgramSpecialInformationParser;
	//* {{ 解析单包的PAT.ccut__50926_0.ts 第一个PAT.
	//* 单section.单PMT.
	unsigned char buf[] = {0x00, 0xB0,0x0D,0x00,0x01,0xC1,0x00,0x00,0x00,0x01,0xEF,0xFF,0x36,0x90,0xE2,0x3D,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
	const unsigned char * pByte = buf;
	int iRet = 0;
	CPPUNIT_ASSERT_NO_THROW(iRet = m_parser->Parser(pByte, sizeof(buf), 0x00));
	CPPUNIT_ASSERT(iRet == 1);
	std::vector<wzd::ProgramAssociationSection> pats;
	CPPUNIT_ASSERT(m_parser->GetPAT(pats));
	CPPUNIT_ASSERT(pats.size() == 1);
	wzd::ProgramAssociationSection pat = *(pats.begin());
	CPPUNIT_ASSERT(pat.table_id == 0);
	CPPUNIT_ASSERT(pat.section_syntax_indicator == 1);
	CPPUNIT_ASSERT(pat.section_length == 0x0d);
	CPPUNIT_ASSERT(pat.transport_stream_id == 1);
	CPPUNIT_ASSERT(pat.version_number == 0);
	CPPUNIT_ASSERT(pat.current_next_indicator == 1);
	CPPUNIT_ASSERT(pat.section_number == 0);
	CPPUNIT_ASSERT(pat.last_section_number == 0);
	CPPUNIT_ASSERT(pat.ProgramMapPids.size() == 1);
	CPPUNIT_ASSERT(pat.NetworkPids.size() == 0);
	wzd::ProgramAssociationSection::pat_info patinfo 
		= *(pat.ProgramMapPids.begin());
	CPPUNIT_ASSERT(patinfo.network_or_program_map_PID == 0x0fff);
	CPPUNIT_ASSERT(patinfo.program_number == 1);
	//* }} */
	delete m_parser;
	m_parser = NULL;
	}

	{
	//* {{
	//* 单Section,多PMT.cctva-10-10-23-44-00.ts
	m_parser = new wzd::CProgramSpecialInformationParser;
	unsigned char buf[] = {0x00,0xB0,0x3D,0x00,0x08,0xC3,0x00,0x00,0x00,0x04,0xE1,0x00,0x00,0x01,0xE1,0x01,0x00,0x03,0xE1,0x02,0x00,0x05,0xE1,0x19,0x00,0x06,0xE1,0x1F,0x00,0x07,0xE1,0x22,0x00,0x08,0xE1,0x23,0x00,0x09,0xE1,0x24,0x00,0x0A,0xE1,0x2B,0x00,0x0B,0xE1,0x35,0x00,0x0C,0xE1,0x36,0x00,0x02,0xE1,0x37,0x00,0x0D,0xE1,0x38,0x52,0x97,0xD7,0xBC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
	const unsigned char* pByte = buf;
	int iRet = 0;
	CPPUNIT_ASSERT_NO_THROW(iRet = m_parser->Parser(pByte, sizeof(buf), 0x00));
	CPPUNIT_ASSERT(iRet == 1);
	std::vector<wzd::ProgramAssociationSection> pats;
	CPPUNIT_ASSERT(m_parser->GetPAT(pats));
	CPPUNIT_ASSERT(pats.size() == 1);
	wzd::ProgramAssociationSection pat = *(pats.begin());
	CPPUNIT_ASSERT(pat.table_id == 0);
	CPPUNIT_ASSERT(pat.section_syntax_indicator == 1);
	CPPUNIT_ASSERT(pat.section_length == 0x3d);
	CPPUNIT_ASSERT(pat.transport_stream_id == 0x8);
	CPPUNIT_ASSERT(pat.version_number == 1);
	CPPUNIT_ASSERT(pat.current_next_indicator == 1);
	CPPUNIT_ASSERT(pat.section_number == 0);
	CPPUNIT_ASSERT(pat.last_section_number == 0);
	CPPUNIT_ASSERT(pat.ProgramMapPids.size() == 13);
	CPPUNIT_ASSERT(pat.NetworkPids.size() == 0);
	vector<wzd::ProgramAssociationSection::pat_info>::const_iterator itr;
		for (itr = pat.ProgramMapPids.begin();
			itr != pat.ProgramMapPids.end();
			++itr)
		{
			switch (itr->program_number)
			{
			case 4:
				CPPUNIT_ASSERT(itr->network_or_program_map_PID == 0x100);
				break;
			case 1:
				CPPUNIT_ASSERT(itr->network_or_program_map_PID == 0x101);
				break;
			case 3:
				CPPUNIT_ASSERT(itr->network_or_program_map_PID == 0x102);
				break;
			case 5:
				CPPUNIT_ASSERT(itr->network_or_program_map_PID == 0x119);
				break;
			case 6:
				CPPUNIT_ASSERT(itr->network_or_program_map_PID == 0x11f);
				break;
			case 7:
				CPPUNIT_ASSERT(itr->network_or_program_map_PID == 0x122);
				break;
			case 8:
				CPPUNIT_ASSERT(itr->network_or_program_map_PID == 0x123);
				break;
			case 9:
				CPPUNIT_ASSERT(itr->network_or_program_map_PID == 0x124);
				break;
			case 0xa:
				CPPUNIT_ASSERT(itr->network_or_program_map_PID == 0x12b);
				break;
			case 0xb:
				CPPUNIT_ASSERT(itr->network_or_program_map_PID == 0x135);
				break;
			case 0xc:
				CPPUNIT_ASSERT(itr->network_or_program_map_PID == 0x136);
				break;
			case 0xd:
				CPPUNIT_ASSERT(itr->network_or_program_map_PID == 0x138);
				break;
			case 2:
				CPPUNIT_ASSERT(itr->network_or_program_map_PID == 0x137);
				break;
			default:
				CPPUNIT_ASSERT(0);
			}
		}
	delete m_parser;
	m_parser = NULL;
	//* }} */
	}
	//* 多Section, 多PMT
	{
	}
}
